/* eslint-env node */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// File paths
const csvPath = path.resolve(__dirname, '../../Copy of GLIDE_BLACKCUBE - Variables.csv');
const processVariablesPath = path.resolve(__dirname, '../data/processVariables.js');
const outputPath = path.resolve(__dirname, '../data/variableDefinitions.js');

console.log('üìñ Generating variable definitions from CSV...');

try {
  // Read CSV file
  const csvContent = fs.readFileSync(csvPath, 'utf-8');
  const lines = csvContent.split('\n');

  // Skip header row
  const dataLines = lines.slice(1);

  // Build a map: variable name ‚Üí definition
  const nameToDefinition = {};

  dataLines.forEach((line, index) => {
    if (!line.trim()) return; // Skip empty lines

    // Parse CSV line (handle quoted fields with commas)
    const columns = parseCSVLine(line);

    // Column 1 (index 0): KEY VARIABLE name
    // Column 14 (index 13): DEFINITION
    const variableName = columns[0]?.trim();
    const definition = columns[13]?.trim();

    if (!variableName || !definition) {
      console.warn(`‚ö†Ô∏è  Skipping line ${index + 2}: Missing variable name or definition`);
      return;
    }

    nameToDefinition[variableName] = definition;
  });

  console.log(`üìä Found ${Object.keys(nameToDefinition).length} definitions in CSV`);

  // Read processVariables.js to extract variable names and IDs
  const processVariablesContent = fs.readFileSync(processVariablesPath, 'utf-8');

  // Extract variable objects using regex
  const variablePattern = /\{\s*id:\s*(\d+),\s*name:\s*["']([^"']+)["']/g;
  const definitions = {};
  let match;
  let matchCount = 0;
  let unmatchedCount = 0;
  const unmatchedVariables = [];

  while ((match = variablePattern.exec(processVariablesContent)) !== null) {
    const id = parseInt(match[1]);
    const name = match[2];

    // Try to find definition by exact name match
    if (nameToDefinition[name]) {
      definitions[id] = nameToDefinition[name];
      matchCount++;
    } else {
      console.warn(`‚ö†Ô∏è  No definition found for variable ID ${id}: "${name}"`);
      unmatchedCount++;
      unmatchedVariables.push(`${id}: ${name}`);
      // Set a fallback message
      definitions[id] = 'Definition not available for this variable.';
    }
  }

  console.log(`‚úÖ Matched ${matchCount} variables`);
  if (unmatchedCount > 0) {
    console.warn(`‚ö†Ô∏è  ${unmatchedCount} variables without definitions:`);
    unmatchedVariables.forEach(v => console.warn(`   - ${v}`));
  }

  // Validate all IDs are present
  const missingIds = [];
  for (let i = 1; i <= 66; i++) {
    if (!definitions[i]) {
      missingIds.push(i);
    }
  }

  if (missingIds.length > 0) {
    console.error(`‚ùå Missing definitions for variable IDs: ${missingIds.join(', ')}`);
  }

  // Generate JavaScript module
  const timestamp = new Date().toISOString();
  const output = `// Auto-generated from Copy of GLIDE_BLACKCUBE - Variables.csv
// Generated: ${timestamp}
// To regenerate: npm run generate:definitions
// DO NOT EDIT THIS FILE MANUALLY

export const variableDefinitions = ${JSON.stringify(definitions, null, 2)};
`;

  // Write to file
  fs.writeFileSync(outputPath, output, 'utf-8');

  console.log(`‚úÖ Generated variableDefinitions.js with ${Object.keys(definitions).length} definitions`);
  console.log(`   Output: ${outputPath}`);

} catch (error) {
  console.error('‚ùå Error generating definitions:', error.message);
  // eslint-disable-next-line no-undef
  process.exit(1);
}

/**
 * Parse CSV line handling quoted fields with commas
 */
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }

  // Add last field
  result.push(current);

  return result;
}
